---
import type { HTMLAttributes } from 'astro/types';

export type Props = HTMLAttributes<'dialog'> & {
    id: string;
};

const { id, ...props } = Astro.props;
---

<dialog id={id} class:list={['popup', props.class]} {...props}>
    <div class="popup__body">
        <slot />
    </div>
</dialog>

<style lang="scss">
    @use '@/app/css/base/variables' as *;
    @use '@/app/css/utils/mixins' as *;  

    .popup {
        --transition-duration: 0.3s;

        transition:
            opacity var(--transition-duration) ease,
            visibility var(--transition-duration) ease,
            display var(--transition-duration) ease-out allow-discrete,
            overlay var(--transition-duration) ease-out allow-discrete;
        max-width: 100%; // стиль обязателен для fullscreen
        max-height: 100%; // стиль обязателен для fullscreen
        width: 100%;
        height: 100%;
        border: 0;
        background: #fff;
        color: #000;
        visibility: hidden;
        display: var(--display, block);
        inset: 0;
        overflow: hidden;
        overflow-y: auto;
        opacity: 0;
        pointer-events: none;
        padding: 0;

        html:not(.transition-behavior-allow-discrete-not-supported) & {
            visibility: visible;
            display: none;
            pointer-events: auto;

            &[open] {
                display: var(--display, block);
            }
        }

        @media (prefers-reduced-motion: reduce) {
            transition: none;
        }

        &:modal {
            max-width: 100%; // стиль обязателен для fullscreen
            max-height: 100%; // стиль обязателен для fullscreen
        }

        &[open] {
            display: var(--display, block);
            visibility: visible;
            opacity: 1;
            pointer-events: auto;

            @starting-style {
                opacity: 0;
            }

            &::backdrop {
                opacity: 1;

                @starting-style {
                    opacity: 0;
                }
            }
        }

        &::backdrop {
            background: rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition:
                opacity var(--transition-duration) ease-out,
                display var(--transition-duration) ease-out allow-discrete,
                overlay var(--transition-duration) ease-out allow-discrete;

            @media (prefers-reduced-motion: reduce) {
                transition: none;
            }
        }
    }
</style>

<script>
    import delegate from 'delegate';
    import { lockBodyScroll, unlockBodyScroll } from '@/shared/lib/dom';

    const transitionBehaviorAllowDiscreteNotSupported =
        navigator.userAgent.includes('Firefox') || !CSS.supports('transition-behavior', 'allow-discrete');

    if (transitionBehaviorAllowDiscreteNotSupported) {
        document.documentElement.classList.add('transition-behavior-allow-discrete-not-supported');
    }

    const closeTimeoutsMap = new Map<HTMLDialogElement, NodeJS.Timeout>();
    const openingTimeoutsMap = new Map<HTMLDialogElement, NodeJS.Timeout>();
    const closingTimeoutsMap = new Map<HTMLDialogElement, NodeJS.Timeout>();

    delegate(document, '[data-dialog-open]', 'click', (event: any) => {
        const target = event.delegateTarget;
        const dialog = document.getElementById(target.getAttribute('data-dialog-open'));

        if (target.getAttribute('data-prevent')) {
            event.preventDefault();
        }

        if (dialog instanceof HTMLDialogElement) {
            dialog.showModal();
        }
    });

    delegate(document, '[data-dialog-close]', 'click', (event: any) => {
        const target = event.delegateTarget;
        const dialog = document.getElementById(target.getAttribute('data-dialog-close'));

        if (target.getAttribute('data-prevent')) {
            event.preventDefault();
        }

        if (dialog instanceof HTMLDialogElement) {
            dialog.close();
        }
    });

    delegate(document, 'dialog', 'click', (event: any) => {
        const target = event.target;
        const delegateTarget = event.delegateTarget;

        if (
            delegateTarget instanceof HTMLDialogElement &&
            delegateTarget.getAttribute('closed-by') === 'any' &&
            delegateTarget === target
        ) {
            delegateTarget.close();
        }
    });

    const mo = new MutationObserver((recs) => {
        recs.forEach(({ attributeName: attr, target: dial }) => {
            if (dial instanceof HTMLDialogElement && attr === 'open') {
                if (dial.open) {
                    dial.dispatchEvent(new Event('popup-open'));

                    const transitionDuration = parseFloat(
                        getComputedStyle(dial).getPropertyValue('--transition-duration') || '0',
                    );

                    clearTimeout(closeTimeoutsMap.get(dial));
                    clearTimeout(openingTimeoutsMap.get(dial));
                    clearTimeout(closingTimeoutsMap.get(dial));

                    lockBodyScroll();
                    dial.classList.add('popup--opening');

                    openingTimeoutsMap.set(
                        dial,
                        setTimeout(
                            () => {
                                dial.classList.remove('popup--opening');
                            },
                            transitionDuration * 1000 + 1,
                        ),
                    );
                } else {
                    dial.dispatchEvent(new Event('popup-close'));

                    const transitionDuration = parseFloat(
                        getComputedStyle(dial).getPropertyValue('--transition-duration') || '0',
                    );

                    clearTimeout(closeTimeoutsMap.get(dial));
                    clearTimeout(openingTimeoutsMap.get(dial));
                    clearTimeout(closingTimeoutsMap.get(dial));

                    closeTimeoutsMap.set(
                        dial,
                        setTimeout(() => {
                            unlockBodyScroll();
                        }, transitionDuration * 1000),
                    );

                    dial.classList.add('popup--closing');

                    closingTimeoutsMap.set(
                        dial,
                        setTimeout(
                            () => {
                                dial.classList.remove('popup--closing');
                            },
                            transitionDuration * 1000 + 1,
                        ),
                    );
                }
            }
        });
    });

    document.querySelectorAll('dialog').forEach((dial) => {
        mo.observe(dial, { attributes: true });
    });
</script>
